My code started entirely from the project walkthrough video.  I found that the video was a great help because although none of the parts of this project are overly demanding, there are so many parts it is easy to get lost.  As the video left it, my vehicle was able to drive a smooth path that did not exceed the speed limit, jerk limit, or acceleration limit.  However the biggest problem was the lane changing method and code organization.

I started working to better organize the code because I do not like having a large main function and would much rather have many small functions that each do a single namable task that add up to a path planner.  Therefore I opted for a path planner class which would greatly reduce the amount of book keeping of all the variables that are flying around.  I also moved most of the functions defined above main into a helper file in order to declutter the main.  Both of these required small changed to the cmake file but that will not effect compilation on different machines.  The largest problem I had with moving things into a class was that my simulator would start bogging down and would crash my system.  I realized that since I was using a class and pushing values onto vectors, the vectors were growing very large and causing the program to crash whereas when all the vectors were made fresh on each message the program ran smoothly.  Therefore I had to add a clear function that cleared out all the vectors at the end of each message callback function.

After I had moved everything into a class my next step was to add better logic in for changing lanes.  I started with a simple check, if I know a vehicle is too close to me and I am going to have to slow down, is there a vehicle next to me that would stop me from changing lanes which was a simple test of all of s coordinates in the sensor fusion list.  This worked well if there was only 1 car ahead of me in my lane, if there were 3 cars ahead of me, all at the same s position, then my car would panic and drive in between the 2 lanes and crash through the wall of cars.  I also needed to add in logic to only change lanes if not only there was no one next to me but also if that lane was clear ahead of me.  I just added in a check of the s value plus some distance, about 45 meters I think, onto my existing lane change check.  This worked very well and got rid of my problem about changing lanes uneccessarily and crashing through a wall of cars.  Since I was moving faster than the traffic I was trying to pass I emphazied changing to the left lane over the right lane by checking the left lane last.  And finally if neither lane was a good option to switch to, I just used the constant slow down code given from the video of v_ref -= .224.

My lane change method allowed me to get around vehicles and not crash however it was a reactive method, making it slower.  I prefer to drive in the middle lane because that way I have the most options to get around slow traffic.  Therefore I added a check to see if I was not in the center lane, is the center lane clear to change to and if it is then change to the center lane.  This allowed my car to be able to actually "pass" vehicles rather than just change lanes to avoid them.

I also did not like the constant slow down if there was no good lane to switch to because it did a horrible job of keeping a constant distance inbetween me and the car ahead of me and I would osciallate around until another lane opened up.  Ideally I would keep the vehicle's speed exactly however I needed to slow down gradually in order to not exert too much impulse on my vehicle.  Therefore I took a difference between my speed and the vehicle's speed and subtracted a small percent of that from my current speed.  It is not an elegant solution but it works.




This code is not an elegant solution.  It does not involve cost function minimization, statistical classifiers like Naive-Bayes, or really anything complex for that matter.  However it works and it works well.  My method of brute force path planning does in a way act like a cost function but a discontinuous one.  Is another lane free yes or no, is there a vehicle in that lane that will block me from going yes or no, am I in the most advantageous lane to travel in yes or no.  A series of 0's or 1's define a deicison boundary for what the vehicle should do however we know exactly what the vehicle will do every time.  There is no guessing over cost function weights because 1 fix breaks something different, each fix for me was independent of other problems.

There is one problem with my current implementation that I choose not to fix.  Right now if I find myself in an edge lane, I do not consider moving to the other edge lane in order to pass a set of 2 cars blocking me.  This would involve two lane changes and while this will make my vehicle get to the goal faster, I decided against adding this behavior because doing so would make my car an ass.  Corteousy does have its place on the road and I think driving across the entire highway to get around someone is rarely appropriate.

Now that I think about it there is another problem that I have not addressed and that is the length of my path.  My car never changes points put onto its path once they have been added which is bad if a car moves into my lane after my path has been planned because if they are moving slower than me then I will rear end them.  This could be accounted for by running a check over the points on the path to see if they are still valid points and if not then erase the ones that are dangerous and replan all the rest.
